(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{490:function(t,s,a){t.exports=a.p+"assets/img/shuangxiangbangding.94056dfa.png"},565:function(t,s,a){"use strict";a.r(s);var e=a(56),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"_1-vue-的双向数据绑定是怎么实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue-的双向数据绑定是怎么实现的"}},[t._v("#")]),t._v(" ◻️ 1. vue 的双向数据绑定是怎么实现的？")]),t._v(" "),e("h4",{attrs:{id:"_1-什么是双向绑定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是双向绑定"}},[t._v("#")]),t._v(" 1. 什么是双向绑定？")]),t._v(" "),e("p",[t._v("Vue 是 MVVM 的模式，在 MVVM 框架下，通过 ViewModel，View 数据的变化会同步到 Model,而 model 数据的变化也会立即反应到 View 上。也就是说，不需要手动操作 DOM 就实现了内容的实时更新。")]),t._v(" "),e("ul",[e("li",[t._v("输入框内容变化时，Data 中的数据同步变化。即 View=>Data")]),t._v(" "),e("li",[t._v("Data 中的数据变化，文本节点的内容同步变化。即 Data=>View")])]),t._v(" "),e("h4",{attrs:{id:"_2-双向绑定的原理是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-双向绑定的原理是什么"}},[t._v("#")]),t._v(" 2. 双向绑定的原理是什么？")]),t._v(" "),e("p",[t._v("首先看看这张图\n"),e("img",{attrs:{src:a(490),alt:"shuangxiangbangding"}}),e("br"),t._v("\n图中有几个需要了解的东西")]),t._v(" "),e("ul",[e("li",[t._v("Observer: "),e("strong",[t._v("数据监听器")]),t._v(",能够对数据的所有属性进行监听，利用 Object.defineProperty()对属性都加上 setter 和 getter。当给一个属性赋值时，就会触发 setter，那么就能监听到数据的变化了。")]),t._v(" "),e("li",[t._v("Dep："),e("strong",[t._v("消息订阅器")]),t._v("，内部有一个收集订阅者(Watcher)的数组，对监听器和订阅者统一管理")]),t._v(" "),e("li",[t._v("Watcher："),e("strong",[t._v("订阅者")]),t._v("，连接 Observer 和 Compile 的桥梁，主要任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息，触发解析器的更新函数。")]),t._v(" "),e("li",[t._v("Compile："),e("strong",[t._v("指令解析器")]),t._v("，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新数据。")])]),t._v(" "),e("p",[t._v("首先，Vue 通过 Object.defineProperty 方法属性拦截的方法，把 data 对象里每个数据的读写转化成 getter 和 setter，当数据变化时，通知数据更新。"),e("br"),t._v("\n数据更新是基于发布-订阅模式实现的。在这个模式下，数据是发布者(Observer),依赖对象是订阅者(watcher),他们需要一个中间人来传递，那就是订阅器(Dep)。"),e("br"),t._v(" "),e("strong",[t._v("总结")]),t._v("：vue 通过数据监听器拦截数据变化，这个数据监听是通过 Object.defindeProperty 方法，他可以把属性的读写转化成 getter 和 setter，当一个属性被赋值的时候，就会触发 setter 函数，从而实现数据的监听。当监听到数据变化之后，会通过一个订阅器通知订阅者某个属性值发生变化，而这个订阅者会结合一个可以对元素指令进行扫描和解析的指令解析器去更新最新的数据。")]),t._v(" "),e("h4",{attrs:{id:"_3-双向数据绑定有什么缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-双向数据绑定有什么缺点"}},[t._v("#")]),t._v(" 3. 双向数据绑定有什么缺点？")]),t._v(" "),e("p",[e("strong",[t._v("Object.defineProperty 不能监听数组下标的变化")]),t._v("\n因为 JavaScript 的限制，Vue 不能检测到数组的变化，所以不能通过操作数组来渲染 dom 的，不能通过属性或者索引控制数组，比如 length，index，解决的方法是通过 set 方法")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("vm"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("items"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("index"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" newVal"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//不能实现")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//push()//pop()//shift()//unshift()//splice()//sort()//reverse()//不能")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 根据索引值赋值")]),t._v("\nVue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("items"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" indexOfItem"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newValue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// vm.$set，Vue.set的一个别名")]),t._v("\nvm"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("$set")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("items"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" indexOfItem"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newValue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Array.prototype.splice")]),t._v("\nvm"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("items"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("splice")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("indexOfItem"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newValue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 修改数组长度")]),t._v("\nvm"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("items"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("splice")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("newLength"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[e("strong",[t._v("vue 实例创建后，再向其上添加属性，不能监听")]),e("br"),t._v("\n解决办法：使用"),e("code",[t._v("Vue.set")]),t._v("设置一个新的对象属性。该方法确保将属性创建为一个响应式属性，并触发视图更新：")]),t._v(" "),e("h2",{attrs:{id:"_2-理解虚拟-dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-理解虚拟-dom"}},[t._v("#")]),t._v(" ◻️ 2.理解虚拟 DOM")]),t._v(" "),e("p",[e("strong",[t._v("Virtul DOM")]),t._v(" 就是对 Dom 的抽象，本质上是一个 Javascript 对象。")]),t._v(" "),e("p",[e("strong",[t._v("为什么要有这个东西呢")]),e("br"),t._v("\n前端优化有一个点就是尽可能地减少手动操作 DOM，因为频繁的变动 DOM 会造成浏览器的重构和回流，这些都会降低性能。而且前端框架都是以不操作 DOM 为基本要求，所以需要引入 Virtual DOM 这个东西，让原本的 DOM 操作让 JS 来完成，而不去麻烦浏览器。")]),t._v(" "),e("p",[e("strong",[t._v("Virtual DOM")]),t._v(" 的 "),e("strong",[t._v("diff")]),t._v(" 算法是 "),e("strong",[t._v("Virtul DOM")]),t._v(" 的核心，它通过比较新旧的 "),e("strong",[t._v("Virtul DOM Tree")]),t._v(" 来找出差异并更新")]),t._v(" "),e("h2",{attrs:{id:"nexttick-的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nexttick-的原理"}},[t._v("#")]),t._v(" nextTick 的原理")]),t._v(" "),e("h2",{attrs:{id:"data、props、watch、computed-methods-的初始化的顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#data、props、watch、computed-methods-的初始化的顺序"}},[t._v("#")]),t._v(" data、props、watch、computed, methods 的初始化的顺序")]),t._v(" "),e("p",[t._v("对照源码可以得出初始化的顺序依次是 prop > methods > data > computed > watch")]),t._v(" "),e("h2",{attrs:{id:"vue-router-的实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-的实现原理"}},[t._v("#")]),t._v(" vue-router 的实现原理")]),t._v(" "),e("p",[t._v("vue 中的路由有两种模式,hash 模式和 history 模式，默认是 hash 模式")]),t._v(" "),e("ul",[e("li",[t._v("Hash 模式：#符号本身以及它后面的字符称之为 hash，可通过 window.location.hash 属性读取。它有以下特点：\n"),e("ul",[e("li",[t._v("hash虽然出现在URL中，但不会被包括在HTTP请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面")]),t._v(" "),e("li",[t._v("可以为hash的改变添加监听事件`\n可以通过监听"),e("strong",[t._v("浏览器的 hashChange 事件")]),t._v("，当 hash 发生改变时，截取 hash 后面的值去获取对应的路由，再把对应路由的内容塞到页面的指定位置，'新页面'就生成了。hash 模式的所有工作都是前端完成的，缺点就是 url 上面有个#,有些人觉得丑")])])]),t._v(" "),e("li",[t._v("History 模式：通过"),e("strong",[t._v("HTML5 提供的一个 history 全局对象")]),t._v("，主要就是依靠于 pushState 与 replaceState\n"),e("ul",[e("li",[t._v("window.history.pushState：可以将给定的数据压入到浏览器会话历史栈中")]),t._v(" "),e("li",[t._v("window.history.replaceState：将当前的会话页面的 url 替换成指定的数据\n他们都会改变当前页面显示的 url，但都不会刷新页面。pushState 是压入浏览器的会话历史栈中，会使得 history.length 加 1，而 replaceState 是替换当前的这条会话历史，因此不会增加 history.length"),e("br"),t._v("\nHistory 模式需要服务端支持，需要配置当请求资源不存在时，返回 index.html\n"),e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/27588422",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考文档"),e("OutboundLink")],1)])])])])])}),[],!1,null,null,null);s.default=n.exports}}]);